set pc, init
dat sys_wfcomp, sys_getmsg, sys_comp
dat pid_alloc, pid_procs, pid_loader

:current_proc
dat pid_a


:init
set [0], sys_yield
set [1], sys_msg

set sp, astack
set pc, afunc

:end
set pc, end

:sys_yield
	set a, [current_proc]
	set [a+7], sp
	set a, [a+6]
	set sp, [a+7]
	set [current_proc], a
	set pc, pop

:sys_msg
	add a, 8
	
:sys_msg_test_ct
	set c, [a]
	and c, 0xff ;lower octet of offset 8 = msg_qty
	
	ifl c, 4 
	set pc, sys_msg_add_it

	;target has too many messages, yield and try again
	set push, a
	set push, b
	set push, x
	set push, y
	set push, z
	
	jsr sys_yield
	
	set z, pop
	set y, pop
	set x, pop
	set b, pop
	set a, pop
	
	set pc, sys_msg_test_ct
	
:sys_msg_add_it
	;at this point c = count of messages in target
	set i, [a]
	shr i, 8       ;index of first message now in i
	
	and [a], 0xff00  ;clear message count
	add c, 1
	bor [a], c        ;set new message count
	sub c, 1
	
	add c, i       
	mod c, 4       ;c = end index in circular buffer
	mul c, 5       ;c*=sizeof(struct pending_msg)
	add a, 1       ;move pointer from offset 8 to offset 9
	add a, c       ;move pointer to entry we should fill in
	
	set [a+0], [current_proc] ;set sender
	set [a+1], b              ;set message
	set [a+2], x              ;set params
	set [a+3], y
	set [a+4], z
	
	set pc, pop
	
:sys_wfcomp
	set [a], 0
	set [a+1], 0

:sys_wfcomp_lp
	set push, a
	jsr sys_yield
	set a, pop
	ife [a], 0
	set pc, sys_wfcomp_lp

	set b,[a]
	set c,[a+1]
	set pc, pop

:sys_getmsg
	set a, [current_proc]
	add a, 8
	set b, [a]
	and b, 0xff ;b = msg_qty
	
	ife b, 0
	set pc, sys_getmsg_nomsg
	
	set c, [a]
	shr c, 8    ;c = first_msg_index
	
	;make new first_msg_index/msg_qty variable
	set i, c
	add i, 1
	mod i, 4
	shl i, 8
	set j, b
	sub j, 1
	bor i, j
	set [a], i
	
	;find location of message
	add a, 1
	mul c, 5
	add a, c
	
	set b,[a+1]
	set x,[a+2]
	set y,[a+3]
	set z,[a+4]
	set a, [a]
	
	set pc, pop
	
:sys_getmsg_nomsg
	set a, 0
	set pc, pop
	
:sys_comp
	set [c], a
	set [c+1], b
	set pc, pop


:pid_alloc
:pid_procs
:pid_loader


:namea
dat "proc a",0

:pid_a
dat namea       ;common_name
dat 0,0,0,0     ;family relationships - not in use yet
dat pid_b,pid_b ;schedule before and after - both are the other process
dat astack-1    ;saved sp
dat 0           ;msg start, qty
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;pending message array
dat 0           ;sig handler, unimplemented
dat 0, 0        ;std in/out procs - unimplemented
:endpid_a

dat 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
:astack

:nameb
dat "proc b",0

:pid_b
dat nameb       ;common_name
dat 0,0,0,0     ;family relationships - not in use yet
dat pid_a,pid_a ;schedule before and after - both are the other process
dat bstack-1    ;saved sp
dat 0           ;msg start, qty
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;pending message array
dat 0           ;sig handler, unimplemented
dat 0, 0        ;std in/out procs - unimplemented
:endpid_b

dat 0, 0, 0, 0, 0, 0, 0, 0, 0, bfunc
:bstack

:bcompstruct
dat 0,0,0


:afunc ;sends two message to bfunc.
set a, pid_b
set b, 1
set x, 2
set y, 3
set z, 4
jsr [1]

set a, pid_b
set b, 1
set x, 2
set y, 3
set z, 4
jsr [1]

set pc, afunc


:bfunc

;read messages one at a time
jsr [3]
ifn  a, 0
set pc, bfunc_gotmail
:bfunc_end

jsr [0]

set pc, bfunc

:bfunc_gotmail
add x, y
add x, z
set c, x
set pc, bfunc_end








