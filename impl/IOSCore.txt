set pc, kickoff
dat sys_wfcomp, sys_getmsg, sys_comp
dat pid_alloc, pid_procs, pid_loader

:current_proc
dat pid_init
dat pid_alloc
dat pid_procs
dat pid_loader


:kickoff
set [0], sys_yield
set [1], sys_msg

set sp, initstack
set pc, init_func

:sys_yield
	set a, [current_proc]
	set [a+7], sp
	set a, [a+6]
	set sp, [a+7]
	set [current_proc], a
	set pc, pop

:sys_msg
	add a, 8
	
:sys_msg_test_ct
	set c, [a]
	and c, 0xff ;lower octet of offset 8 = msg_qty
	
	ifl c, 4 
	set pc, sys_msg_add_it

	;target has too many messages, yield and try again
	set push, a
	set push, b
	set push, x
	set push, y
	set push, z
	
	jsr sys_yield
	
	set z, pop
	set y, pop
	set x, pop
	set b, pop
	set a, pop
	
	set pc, sys_msg_test_ct
	
:sys_msg_add_it
	;at this point c = count of messages in target
	set i, [a]
	shr i, 8       ;index of first message now in i
	
	and [a], 0xff00  ;clear message count
	add c, 1
	bor [a], c        ;set new message count
	sub c, 1
	
	add c, i       
	mod c, 4       ;c = end index in circular buffer
	mul c, 5       ;c*=sizeof(struct pending_msg)
	add a, 1       ;move pointer from offset 8 to offset 9
	add a, c       ;move pointer to entry we should fill in
	
	set [a+0], [current_proc] ;set sender
	set [a+1], b              ;set message
	set [a+2], x              ;set params
	set [a+3], y
	set [a+4], z
	
	set pc, pop
	
:sys_wfcomp
	set [a], 0
	set [a+1], 0

:sys_wfcomp_lp
	set push, a
	jsr sys_yield
	set a, pop
	ife [a], 0
	set pc, sys_wfcomp_lp

	set b,[a]
	set c,[a+1]
	set pc, pop

:sys_getmsg
	set a, [current_proc]
	add a, 8
	set b, [a]
	and b, 0xff ;b = msg_qty
	
	ife b, 0
	set pc, sys_getmsg_nomsg
	
	set c, [a]
	shr c, 8    ;c = first_msg_index
	
	;make new first_msg_index/msg_qty variable
	set i, c
	add i, 1
	mod i, 4
	shl i, 8
	set j, b
	sub j, 1
	bor i, j
	set [a], i
	
	;find location of message
	add a, 1
	mul c, 5
	add a, c
	
	set b,[a+1]
	set x,[a+2]
	set y,[a+3]
	set z,[a+4]
	set a, [a]
	
	set pc, pop
	
:sys_getmsg_nomsg
	set a, 0
	set pc, pop
	
:sys_comp
	set [c], a
	set [c+1], b
	set pc, pop

:nameinit
dat "INIT",0
:namealloc
dat "ALLOC",0
:nameprocs
dat "PROCS",0
:nameloader
dat "LOADER",0

:pid_alloc
dat namealloc            ;common_name
dat 0,0,0,0              ;reserved
dat pid_init,pid_procs
dat allocstack-1         ;saved sp
dat 0                    ;msg start, qty
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;pending message array
dat 0                    ;reserved
dat 0, 0                 ;std in/out procs - unimplemented


dat 0, 0, 0, 0, 0, 0, 0, alloc_func
:allocstack



:pid_procs
dat nameprocs            ;common_name
dat 0,0,0,0              ;reserved
dat pid_alloc,pid_loader
dat procsstack-1         ;saved sp
dat 0                    ;msg start, qty
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;pending message array
dat 0                    ;reserved
dat 0, 0                 ;std in/out procs - unimplemented


dat 0, 0, 0, 0, 0, 0, 0, procs_func
:procsstack



:pid_loader
dat nameloader           ;common_name
dat 0,0,0,0              ;reserved
dat pid_procs,pid_init
dat loaderstack-1        ;saved sp
dat 0                    ;msg start, qty
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;pending message array
dat 0                    ;reserved
dat 0, 0                 ;std in/out procs - unimplemented


dat 0, 0, 0, 0, 0, 0, 0, loader_func
:loaderstack



:pid_init
dat nameinit             ;common_name
dat 0,0,0,0              ;reserved
dat pid_loader,pid_alloc
dat initstack-1          ;saved sp
dat 0                    ;msg start, qty
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;pending message array
dat 0                    ;reserved
dat 0, 0                 ;std in/out procs - unimplemented


dat 0, 0, 0, 0, 0, 0, 0, 0
:initstack


:init_func 
set a, a
set a, a
set a, a
set a, a
set a, a
set a, a
jsr [0]
set pc, init_func

:alloc_func
set a, a
set a, a
set a, a
set a, a
set a, a
set a, a
jsr [0]
set pc, alloc_func

:procs_func 
set a, a
set a, a
set a, a
set a, a
set a, a
set a, a
jsr [0]
set pc, procs_func

:loader_func 
set a, a
set a, a
set a, a
set a, a
set a, a
set a, a
jsr [0]
set pc, loader_func

