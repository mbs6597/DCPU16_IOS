;Offset declarations

;task struct offsets
org 0
:task_common_name_off
org 5
:task_sched_prev_off
org 6
:task_sched_next_off
org 7
:task_saved_sp_off
org 8
:task_msg_count_off
org 9
:task_msg_queue_off
org 30
:task_stdout_pid_off
org 31
:task_stdin_pid_off
org 32
:task_size

org 4
:task_qty_messages

;pending_message struct offset
org 0
:msg_sender_offset
org 1
:msg_message_offset
org 2
:msg_p1_offset
org 3
:msg_p2_offset
org 4
:msg_p3_offset
org 5
:msg_size


org 0

:raw_image_start
set pc, kickoff
dat sys_wfcomp, sys_getmsg, sys_comp
dat pid_alloc, pid_procs, pid_loader

:current_proc
dat pid_init


:kickoff
;fill syscall entries covered by jump
set [0], sys_yield
set [1], sys_msg

;setup core PID structs
set i, pid_alloc
set b, 32
set c, 0
jsr memset

set [pid_alloc+task_common_name_off], namealloc
set [pid_alloc+task_saved_sp_off],    allocstack
set [pid_alloc+task_sched_prev_off],  pid_init
set [pid_alloc+task_sched_next_off],  pid_procs


set i, pid_procs
set b, 32
set c, 0
jsr memset

set [pid_procs+task_common_name_off], nameprocs
set [pid_procs+task_saved_sp_off],    procsstack
set [pid_procs+task_sched_prev_off],  pid_alloc
set [pid_procs+task_sched_next_off],  pid_loader


set i, pid_loader
set b, 32
set c, 0
jsr memset

set [pid_loader+task_common_name_off], nameloader
set [pid_loader+task_saved_sp_off],    loaderstack
set [pid_loader+task_sched_prev_off],  pid_procs
set [pid_loader+task_sched_next_off],  pid_init


set i, pid_init
set b, 32
set c, 0
jsr memset

set [pid_init+task_common_name_off], nameinit
set [pid_init+task_sched_prev_off],  pid_loader
set [pid_init+task_sched_next_off],  pid_alloc

;setup initial stacks
set [loaderstack], loader_func
set [allocstack], alloc_func
set [procsstack], procs_func

;dive into init process
set sp, initstack
set pc, init_func

:sys_yield
	set a, [current_proc]
	set [a+task_saved_sp_off], sp
	set a, [a+task_sched_next_off]
	set sp, [a+task_saved_sp_off]
	set [current_proc], a
	set pc, pop

:sys_msg
	add a, task_msg_count_off
	
:sys_msg_test_ct
	set c, [a]
	and c, 0xff ;lower octet = msg_qty
	
	ifl c, task_qty_messages 
	set pc, sys_msg_add_it

	;target has too many messages, yield and try again
	set push, a
	set push, b
	set push, x
	set push, y
	set push, z
	
	jsr sys_yield
	
	set z, pop
	set y, pop
	set x, pop
	set b, pop
	set a, pop
	
	set pc, sys_msg_test_ct
	
:sys_msg_add_it
	;at this point c = count of messages in target
	set i, [a]
	shr i, 8         ;index of first message now in i
	
	and [a], 0xff00  ;clear message count
	add c, 1
	bor [a], c       ;set new message count
	sub c, 1
	
	add c, i       
	mod c, task_qty_messages ;c = end index in circular buffer
	mul c, msg_size          ;c*=sizeof(struct pending_msg)
	add a, (task_msg_queue_off-task_msg_count_off)                
	add a, c                 ;move pointer to entry we should fill in
	
	set [a+msg_sender_offset],  [current_proc]
	set [a+msg_message_offset], b              
	set [a+msg_p1_offset],      x              
	set [a+msg_p2_offset],      y
	set [a+msg_p3_offset],      z
	
	set pc, pop
	
:sys_wfcomp
	set [a], 0
	set [a+1], 0

:sys_wfcomp_lp
	set push, a
	jsr sys_yield
	set a, pop
	ife [a], 0
	set pc, sys_wfcomp_lp

	set b,[a]
	set c,[a+1]
	set pc, pop

:sys_getmsg
	set a, [current_proc]
	add a, 8
	set b, [a]
	and b, 0xff ;b = msg_qty
	
	ife b, 0
	set pc, sys_getmsg_nomsg
	
	set c, [a]
	shr c, 8    ;c = first_msg_index
	
	;make new first_msg_index/msg_qty variable
	set i, c
	add i, 1
	mod i, 4
	shl i, 8
	set j, b
	sub j, 1
	bor i, j
	set [a], i
	
	;find location of message
	add a, 1
	mul c, 5
	add a, c
	
	set b,[a+1]
	set x,[a+2]
	set y,[a+3]
	set z,[a+4]
	set a, [a]
	
	set pc, pop
	
:sys_getmsg_nomsg
	set a, 0
	set pc, pop
	
:sys_comp
	set [c], a
	set [c+1], b
	set pc, pop

:nameinit
dat "INIT",0
:namealloc
dat "ALLOC",0
:nameprocs
dat "PROCS",0
:nameloader
dat "LOADER",0

:init_func 
set a, a
set a, a
set a, a
set a, a
set a, a
set a, a
jsr [0]
set pc, init_func

:alloc_func
;Have alloc claim all of the static kernel image as its own memory
	set x, kernel_bss_end
	shr x, 8

	ifn ex, 0
	add x, 1  ;divide by 256 round up

	set i, alloc_map_start
	set b, x
	set c, pid_alloc
	
	jsr memset
	
	set b, alloc_map_end - alloc_map_start
	sub b, x
	set c, 0
	
	jsr memset
	
:alloc_loop
	jsr [0]
	set pc, alloc_loop



:procs_func 
set a, a
set a, a
set a, a
set a, a
set a, a
set a, a
jsr [0]
set pc, procs_func

:loader_func 
set a, a
set a, a
set a, a
set a, a
set a, a
set a, a
jsr [0]
set pc, loader_func


:memset         
;pre:
;i = start address, b = length, c = value
;post:
;i = 1 past last word written, b = undefined, j undefined, all others same
set pc, memset_lp_cond
:memset_lp
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c

	sub b, 16

:memset_lp_cond
	ifa b, 15
	set pc, memset_lp

	ifu b, 1
	set pc, pop

	add b, 7
	sub pc, b


:kernel_text_end


:kernel_bss_start

:pid_alloc
dat namealloc            ;common_name
dat 0,0,0,0              ;reserved
dat pid_init,pid_procs
dat allocstack           ;saved sp
dat 0                    ;msg start, qty
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;pending message array
dat 0                    ;reserved
dat 0, 0                 ;std in/out procs - unimplemented

:pid_procs
dat nameprocs            ;common_name
dat 0,0,0,0              ;reserved
dat pid_alloc,pid_loader
dat procsstack           ;saved sp
dat 0                    ;msg start, qty
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;pending message array
dat 0                    ;reserved
dat 0, 0                 ;std in/out procs - unimplemented

:pid_loader
dat nameloader           ;common_name
dat 0,0,0,0              ;reserved
dat pid_procs,pid_init
dat loaderstack          ;saved sp
dat 0                    ;msg start, qty
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;pending message array
dat 0                    ;reserved
dat 0, 0                 ;std in/out procs - unimplemented

:pid_init
dat nameinit             ;common_name
dat 0,0,0,0              ;reserved
dat pid_loader,pid_alloc
dat initstack            ;saved sp
dat 0                    ;msg start, qty
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;pending message array
dat 0                    ;reserved
dat 0, 0                 ;std in/out procs - unimplemented



:alloc_map_start
dat 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 ;simulating uninitialized data for the hell of it
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 ;in this section. Not sure what "reset" will look
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 ;like so I'm building it in from the start.
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1

:alloc_map_end
dat 0, 0, 0, 0, 0, 0, 0, 0
:initstack

dat 0, 0, 0, 0, 0, 0, 0
:loaderstack
dat 0


dat 0, 0, 0, 0, 0, 0, 0
:procsstack
dat 0

dat 0, 0, 0, 0, 0, 0, 0
:allocstack
dat 0

:kernel_bss_end