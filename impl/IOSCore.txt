;Offset declarations

;task struct offsets
org 0
:task_common_name_off
org 5
:task_sched_prev_off
org 6
:task_sched_next_off
org 7
:task_saved_sp_off
org 8
:task_msg_count_off
org 9
:task_msg_queue_off
org 30
:task_stdout_pid_off
org 31
:task_stdin_pid_off
org 32
:task_size

org 4
:task_qty_messages

;pending_message struct offset
org 0
:msg_sender_offset
org 1
:msg_message_offset
org 2
:msg_p1_offset
org 3
:msg_p2_offset
org 4
:msg_p3_offset
org 5
:msg_size


org 0

:kernel_text_start

	set pc, kickoff

org 2

:SYS_YIELD
	dat sys_yield_fn

:SYS_MSG
	dat sys_msg_fn

:SYS_WFCOMP
	dat sys_wfcomp_fn

:SYS_GETMSG
	dat sys_getmsg_fn

:SYS_COMP
	dat sys_comp_fn

:SYS_ALLOC
	dat pid_alloc

:SYS_PROCS
	dat pid_procs

:SYS_LOADER
	dat pid_loader

:current_proc
	dat pid_init


:kickoff

	;setup core PID structs
	set i, pid_alloc
	set x, namealloc
	set y, allocstack-1
	set j, 0
	
	jsr mkblankproc
	
	
	set i, pid_procs
	set x, nameprocs
	set y, procsstack-1
	set j, pid_alloc
	
	jsr mkblankproc
	
	
	set i, pid_loader
	set x, nameloader
	set y, loaderstack-1
	set j, pid_procs
	
	jsr mkblankproc
	
	
	set i, pid_init
	set x, nameinit
	set y, initstack-1
	set j, pid_loader
	
	jsr mkblankproc

;setup initial stacks
	set [loaderstack-1], loader_func
	set [allocstack-1], alloc_func
	set [procsstack-1], procs_func

;dive into init process
	set sp, initstack
	set pc, init_func

:mkblankproc
;pre:
;i = pid block
;j = pid to link after, null for self link
;x = name ptr
;y = init sp location
;post:
;destroys params, b, c
	set push, i
	set push, j
	set b, 32
	set c, 0
	jsr memset

	set j, pop
	set i, pop

	set [i+task_common_name_off], x
	set [i+task_saved_sp_off],    y
	
	ifn j, 0
	set pc, mkblankproc_link

	set [i+task_sched_prev_off], i
	set [i+task_sched_next_off], i
	set pc, pop

:mkblankproc_link

	set [i+task_sched_next_off], [j+task_sched_next_off]
	set [i+task_sched_prev_off], j

	set c, [i+task_sched_next_off]

	set [c+task_sched_prev_off], i
	set [j+task_sched_next_off], i

	set pc, pop


:sys_yield_fn
	set a, [current_proc]
	set [a+task_saved_sp_off], sp
	set a, [a+task_sched_next_off]
	set sp, [a+task_saved_sp_off]
	set [current_proc], a
	set pc, pop

:sys_msg_fn
	add a, task_msg_count_off
	
:sys_msg_test_ct
	set c, [a]
	and c, 0xff ;lower octet = msg_qty
	
	ifl c, task_qty_messages 
	set pc, sys_msg_add_it

	;target has too many messages, yield and try again
	set push, a
	set push, b
	set push, x
	set push, y
	set push, z
	
	jsr sys_yield_fn
	
	set z, pop
	set y, pop
	set x, pop
	set b, pop
	set a, pop
	
	set pc, sys_msg_test_ct
	
:sys_msg_add_it
	;at this point c = count of messages in target
	set i, [a]
	shr i, 8         ;index of first message now in i
	
	and [a], 0xff00  ;clear message count
	add c, 1
	bor [a], c       ;set new message count
	sub c, 1
	
	add c, i       
	mod c, task_qty_messages ;c = end index in circular buffer
	mul c, msg_size          ;c*=sizeof(struct pending_msg)
	add a, (task_msg_queue_off-task_msg_count_off)                
	add a, c                 ;move pointer to entry we should fill in
	
	set [a+msg_sender_offset],  [current_proc]
	set [a+msg_message_offset], b              
	set [a+msg_p1_offset],      x              
	set [a+msg_p2_offset],      y
	set [a+msg_p3_offset],      z
	
	set pc, pop
	
:sys_wfcomp_fn
	set [a], 0
	set [a+1], 0

:sys_wfcomp_lp
	set push, a
	jsr sys_yield
	set a, pop
	ife [a], 0
	set pc, sys_wfcomp_lp

	set b,[a]
	set c,[a+1]
	set pc, pop

:sys_getmsg_fn
	set a, [current_proc]
	add a, 8
	set b, [a]
	and b, 0xff ;b = msg_qty
	
	ife b, 0
	set pc, sys_getmsg_nomsg
	
	set c, [a]
	shr c, 8    ;c = first_msg_index
	
	;make new first_msg_index/msg_qty variable
	set i, c
	add i, 1
	mod i, 4
	shl i, 8
	set j, b
	sub j, 1
	bor i, j
	set [a], i
	
	;find location of message
	add a, 1
	mul c, 5
	add a, c
	
	set b,[a+1]
	set x,[a+2]
	set y,[a+3]
	set z,[a+4]
	set a, [a]
	
	set pc, pop
	
:sys_getmsg_nomsg
	set a, 0
	set pc, pop
	
:sys_comp_fn
	set [c], a
	set [c+1], b
	set pc, pop

:nameinit
dat "INIT",0
:namealloc
dat "ALLOC",0
:nameprocs
dat "PROCS",0
:nameloader
dat "LOADER",0

:init_func 
set a, a
set a, a
set a, a
set a, a
set a, a
set a, a
jsr [SYS_YIELD]
set pc, init_func

:alloc_func
;Have alloc claim all of the static kernel image as its own memory
	set x, kernel_bss_end
	shr x, 8

	ifn ex, 0
	add x, 1  ;divide by 256 round up

	set i, alloc_map_start
	set b, x
	set c, pid_alloc
	
	jsr memset
	
	set b, alloc_map_end - alloc_map_start
	sub b, x
	set c, 0
	
	jsr memset
	
:alloc_loop
	jsr [SYS_YIELD]
	set pc, alloc_loop



:procs_func 
set a, a
set a, a
set a, a
set a, a
set a, a
set a, a
jsr [SYS_YIELD]
set pc, procs_func

:loader_func 
set a, a
set a, a
set a, a
set a, a
set a, a
set a, a
jsr [SYS_YIELD]
set pc, loader_func


:memset         
;pre:
;i = start address, b = length, c = value
;post:
;i = 1 past last word written, b = undefined, j undefined, all others same
set pc, memset_lp_cond
:memset_lp
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c
	sti [i], c

	sub b, 16

:memset_lp_cond
	ifa b, 15
	set pc, memset_lp

	ifu b, 1
	set pc, pop

	add b, 7
	sub pc, b


:kernel_text_end


:kernel_bss_start

:pid_alloc

org (pid_alloc+32)
:pid_procs

org (pid_procs+32)
:pid_loader

org (pid_loader+32)
:pid_init


org (pid_init+32)

:alloc_map_start

org (alloc_map_start+256)
:alloc_map_end


org (alloc_map_end+8)
:initstack

org (initstack+8)
:loaderstack

org (loaderstack+8)
:procsstack


org (procsstack+8)
:allocstack

:kernel_bss_end